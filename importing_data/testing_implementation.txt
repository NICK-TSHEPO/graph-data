FOR TESTING

//1. Show Schema
CALL db.schema.visualization();


ğŸ‘‰ â€œThis is the schema of my database. I have Users, Posts, Comments, Media, Hashtags, and URLs, connected with relationships such as CREATED, FOLLOWS, LIKED, REPLIES_TO, TAGGED_WITH, and so on. I already created the constraints and imports, so Iâ€™ll just show the results here.â€

//2. Show Some Users
MATCH (u:User)
RETURN u.displayName, u.joinedAt
LIMIT 5;


ğŸ‘‰ â€œHere are some users with their display names and the dates they joined.â€


//3. Comments on Posts
MATCH (c:Comment)-[:REPLIES_TO]->(p:Post)
RETURN c.commentId, c.text, p.postId
LIMIT 5;


ğŸ‘‰ â€œHere we can see comments that reply to posts. Some comments also reply to other comments, creating discussion threads.â€

//4. Friend-of-Friend (Path Query)
MATCH (a:User {displayName:"Alicia Keys"})-[:FOLLOWS*2]-(fof:User)
RETURN DISTINCT fof.displayName;


ğŸ‘‰ â€œThis query finds friends-of-friends of Alicia Keys by traversing two FOLLOWS relationships.â€

//5. Users Who Liked the Same Post (Pattern Matching)
MATCH (u1:User)-[:LIKED]->(p:Post)<-[:LIKED]-(u2:User)
WHERE u1 <> u2
RETURN u1.displayName, u2.displayName, p.postId
LIMIT 5;


ğŸ‘‰ â€œThis query finds users who liked the same post, showing hidden communities of interest.â€

//6. Most Liked Post (Aggregation)
MATCH (u:User)-[:LIKED]->(p:Post)
RETURN p.postId, COUNT(u) AS likeCount
ORDER BY likeCount DESC
LIMIT 1;


ğŸ‘‰ â€œThis finds the most liked post in the dataset.â€

//7. Write Query (Create New Like)
MATCH (u:User {displayName:"Mark"}), (p:Post {postId:"p1"})
MERGE (u)-[:LIKED]->(p);


ğŸ‘‰ â€œHere I create a new like from Mark to post p1. MERGE ensures it only adds it if it doesnâ€™t already exist.â€

//8. PageRank (Influence)
CALL gds.pageRank.stream('userGraph')
YIELD nodeId, score
RETURN gds.util.asNode(nodeId).displayName AS user, score
ORDER BY score DESC
LIMIT 5;


ğŸ‘‰ â€œThis is PageRank, an algorithm that ranks the most influential users in the network based on follow relationships.â€

//9. Louvain (Communities)
CALL gds.louvain.stream('userGraph')
YIELD nodeId, communityId
RETURN gds.util.asNode(nodeId).displayName AS user, communityId
ORDER BY communityId, user;


ğŸ‘‰ â€œThis is Louvain community detection. It groups users into communities based on who follows whom.â€